#!/usr/bin/env perl6
# Copyright 2016 cygx <cygx@cpan.org>
# Distributed under the Boost Software License, Version 1.0

use v6;
use nqp;

nqp::loadbytecode('nqp.moarvm');
nqp::getcomp('nqp').eval(q:to/END/);
my $global_cuuid := 0;
my $assembler := nqp::getcomp('MAST');
my %types := nqp::hash(
    'int', int,
    'num', num,
    'str', str,
    'obj', NQPMu
);

class MoarASM {
    method cu() {
        MAST::CompUnit.new();
    }

    method compile($cu) {
        $assembler.assemble_and_load($cu);
    }

    method dump($cu, $file) {
        $assembler.assemble_to_file($cu, $file);
    }

    method mainline($bc) {
        nqp::compunitmainline($bc);
    }

    method iv($value, :$size = 64) {
        MAST::IVal.new(:$value, :$size, signed => 1);
    }

    method uv($value, :$size = 64) {
        MAST::IVal.new(:$value, :$size, signed => 0);
    }

    method nv($value, :$size = 64) {
        MAST::NVal.new(:$value, :$size);
    }

    method sv($value) {
        MAST::SVal.new(:$value);
    }

    method local($index) {
        MAST::Local.new(:$index);
    }

    method node() {
        MAST::Node;
    }

    method add_local($frame, $typename) {
        nqp::die("unknown type: $typename")
            unless nqp::existskey(%types, $typename);

        my $type := %types{$typename};
        self.local($frame.add_local($type));
    }

    method add_frame($cu, $name = '<anon>', $cuuid = ~$global_cuuid++) {
        my $frame := MAST::Frame.new(:$name, :$cuuid);
        $cu.add_frame($frame);
        $frame;
    }

    method push_op($frame, $op, *@args) {
        nqp::die("unknown op: $op")
            unless nqp::existskey(%MAST::Ops::codes, $op);

        nqp::push($frame.instructions(), MAST::Op.new(:$op, |@args));
    }

    method push_call($frame, $target, :@flags, :$result, *@args) {
        nqp::push($frame.instructions(),
            MAST::Call.new(:$target, :@flags, :$result, |@args));
    }
}

nqp::bindcurhllsym('MoarASM', MoarASM);
END

my \asm = nqp::gethllsym('nqp', 'MoarASM');

sub arg($_) {
    when /^ (\d+) $/ { asm.uv(+~$0) }
    when /^ (<[+-]> \d+) $/ { asm.iv(+~$0) }
    when /^ \' (.*?) \' $/ { asm.sv(~$0) }
    when /^ (\w+) \: $/ { asm.sv(~$0) }
    when /^ \% (\d+) $/ { asm.local(+~$0) }
    when /^ \& (\w+) $/ { %*frames{~$0} }
    when /^ \@ (\w+) $/ { %*aliases{~$0} }
    default { die "syntax error: $_" }
}

sub parse($src) {
    my $n = 0;
    my $line;

    CATCH {
        note ~$_;
        note "[{$n}] $line" if defined $line;
        exit 1;
    }

    my $cu := asm.cu;
    my $frame;
    my %*frames;
    my %*aliases;
    my $flags := nqp::list();
    my $result := asm.node;

    for $src.IO.lines(:close) {
        ++$n;
        next if /^\#/;

        my ($op, @args) = .comb(/\S+|\'.*?\'/);
        next unless defined $op;

        $line = $_;

        given $op {
            when '.alias' {
                die "syntax error: expected 2 args" unless @args == 2;
                %*aliases{@args[0]} := arg @args[1];
            }
            when '.hll' { $cu.hll(|@args) }
            when '.frame' {
                %*aliases = ();
                $frame := @args
                    ?? (%*frames{@args[0]}
                    // (%*frames{@args[0]} := asm.add_frame($cu, |@args)))
                    !! asm.add_frame($cu);
            }
            when '.local' { asm.add_local($frame, $_) for @args }
            when /^ '.local[' (\w+) ']' $/ {
                my $type := ~$0;
                %*aliases{$_} := asm.add_local($frame, $type)
                    for @args;
            }
            when /^ '.const[' (\w+) ']' $/ {
                die "syntax error: expected 2 args" unless @args == 2;
                my $type := ~$0;
                my $local := asm.add_local($frame, $type);
                %*aliases{@args[0]} := $local;
                my $op := do given $type {
                    when 'str' { 'const_s' }
                    default { die "syntax error: $_" }
                }
                asm.push_op($frame, $op, $local, arg(@args[1]));
            }
            when /^ '.param[' (\w+) ']' $/ {
                die "syntax error: expected 2 args" unless @args == 2;
                my $type := ~$0;
                my $local := asm.add_local($frame, $type);
                %*aliases{@args[0]} := $local;
                my $op := do given $type {
                    when 'str' { 'param_rp_s' }
                    default { die "syntax error: $_" }
                }
                asm.push_op($frame, $op, $local, arg(@args[1]));
            }
            when '.flags' {
                for @args {
                    nqp::push($flags, do {
                        when 'obj' { 1 }
                        when 'int' { 2 }
                        when 'num' { 4 }
                        when 'str' { 8 }
                        when ':obj' { 1 +| 32 }
                        when ':int' { 2 +| 32 }
                        when ':num' { 4 +| 32 }
                        when ':str' { 8 +| 32 }
                        #when 'flat' { 64 }
                        #when 'flatnamed' { 128 }
                    });
                }
            }
            when '.result' {
                die "syntax error: expected 1 arg" unless @args == 1;
                $result := arg @args[0];
            }
            when '.call' {
                asm.push_call($frame, :$flags, :$result, |@args.map(&arg));
                $flags := nqp::list();
                $result := asm.node;
            }
            when '.set' {
                for @args {
                    when 'load' { $cu.load_frame($frame) }
                    when 'main' { $cu.main_frame($frame) }
                    default { die "syntax error: $_" }
                }
            }
            when /^\./ { die "syntax error: $_" }
            default { asm.push_op($frame, $op, |@args.map(&arg)) }
        }
    }

    $cu;
}

multi MAIN(Str $src, Str $dest) {
    asm.dump(parse($src), $dest);
}

multi MAIN(Str $src, Bool :$dump!) {
    say parse($src).dump();
}

multi MAIN(Str $src, Bool :$run!, *@args) {
    asm.mainline(asm.compile(parse($src))).(|@args);
}
